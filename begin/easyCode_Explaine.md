### 내 이름 찾기
- 이름을 배열로 받아 index()함수를 사용하여 위치를 찾는다
----------------------------
### 정렬된 많은 원소 사이에서 특정 원소 찾기
- index() 함수를 사용해도 되지만 그러면 시간복잡도가 O(n)이기 때문에 for문을 사용해서 break를 거는 것을 사용하였다.
-------------------------------
### 타일 채우기1
1. dynamic 알고리즘을 사용해서 풀었다.
규칙은 다음과 같다  
N = 1 : 1개  
N = 2 : 2개  
N = 3 : 3개 (이전 1, 2 의 조합 4개에서 중복 -1)  
N = 4 : 5개 (이전 3의 조합에서 1의 조합을 붙인 후 중복 -1)  
N = 5 : 8개 (이전 3, 4 의 개수의 합)  
N = 6 : 13개 (이전 4, 5의 합)  
........  
그러므로 점화식은  
dp[N] = dp[N-1] + dp[N-2]  
나머지 789789로 나와야 하므로 %789789를 한다
---------------------------------
### 우리반 아이큐 왕
1. N을 입력 받는다
2. N만큼 반복을 한다
    - 입력을 한줄 씩 받아 각각 저장한다
    - start = 2로 정하고 end = 3으로 정해 놓는다
    - dp[0]과 IQ값을 비교하여 더 크면 end = 0을 넣는다
    - 그렇지 않고 dp[1]보다 크면 end = 1을 넣는다
    - 그렇지 않고 dp[2]보다 크면 end = 2를 넣는다
    - start와 end 만큼 for문 반복하여 -1 씩 반복하며 dp[N] = dp[N-1]을 이름과 IQ를 넣는다
    - 단, end값이 3이 아닐때만 dp[end]에 새로운 값을 넣어준다
    - end 를 3으로 reset한다
3. 이름들을 출력한다
---------------------------------
### 사전만들기( 나중에 다시 적기)
1. N 값을 입력 받아 저장
2. N크기만큼 eDict 생성
2-1. start = 0
3. for n in range(1, N+1)  
    3-1.  
    save에 단어를 받는다   
    end = 0  
    same =  (0 = none, 1 = same word)   
    3-2.  
    for i in range (0, n) 
    - 만약 len(dp[i]) > len(save) 이면 end = i, break  
    (만약 저장된 글자가 입력받은 글자보다 길다면 end 시작점은 저장된 글자의 위치로 넣고 break를 건다 )  
    - 그렇지 않고,  len(dp[i]) == len(save) 이면 
        - if dp[i] > save ==> end = i, break
        - elif dp[i] == save, same = 1  break  
        (그렇지 않고 저장된 글자와 입력받은 글자의 길이가 같다면 첫번째 알파벳 순으로 해서 저장된 글자가 더 알파벳 순서가 뒤라면 end 시작점은 저장된 글자로 저장하고 break를 건다  
        그렇지 않고 저장된 글자와 입력받은 글자가 동일한 글자이면 same = 0으로 하고 break를 건다)   
    - 그렇지 않고, len(dp[i]) < len(save) 이면 end = i-1 break  
    (그렇지 않고 입력받은 글자의 길이가 저장된 길이보다 길다면 end 시작점은 저장된 글자의 위치 뒤로 넣고 break를 건다)
      
    3-3.  
    만약 same == 0면,  
        for j in range (start, end, -1)  
        - dp[j] = dp[j-1]   
        (start, end-1 까지 1씩 줄어들면서 모든 글자들의 저장된 위치를 한칸씩 뒤로 미룬다)  

        dp[end] = save
        (마지막에 end 자리에 입력받은 글자를 넣는다)  
        start ++    
        (start의 위치를 올려준다 ==> start는 전체 배열중 마지막 글자의 위치를 나타낸다)
-----------------------------
### 무향그래프
==> 무향그래프를 인접행렬로 표현하는 것   
1. N(노드의 개수), M(엣지의 개수를 입력받는다)  
1<= N,M <= 1000 이므로 엣지가 최대 1000개 생성된다는 것이다.  
엣지가 1000개가 되려면 노드의 수는 최대 45개 (45C2)가 최대 한계이다.  
그러므로 시간복잡도에 대해서는  
배열생성 (45X45), 할당 1000, 출력 (45X45) => 5050이 최대이므로 복잡하게 생각하지 않아도 된다
2. NxN개의 2차원 리스트를 생성한다
3. M번만큼 x, y를 d[x-1][y-1], d[y-1][x-1]로 엣지를 할당해 준다
4. NXN 만큼 인접행렬을 출력해 준다
-----------------------------
### 누적합
==> 누적합은 두수의 합이 다음 수의 결과가 되는 것으로 구간 별 합을 구할 때 필요한 알고리즘이다. 이 누적합을 조금 더 발전 시킨 것이 세그멘트 트리이다.  
  
이 트리는 이진 트리로 (부모 * 2), (부모 * 2 + 1)이 자식 값이 되는 트리이다.  
또한 전체노드의 수는 2 ** (트리의 높이) 이고, 맨 아래 노드의 첫번째 노드의 값은 2 ** (트리의 높이-1) 이다.  
  
1. 합해야 할 숫자 개수 N을 입력 받는다
2. 합해야 할 숫자들을 입력받아 temp에 담는다
3. 총 노드수, 첫번째 노드 위치를 계산하여 저장한다  
    트리의 높이 : int(N의 log2 값) + (2의 제곱이면 1, 아니면 2) 
    총 노드수 : 2 ** (트리의 높이)  
    제일 아래 높이의 첫번째 노드 위치 : 2 ** (트리높이-1)  
      
4. (0, 총 노드수) 만큼 반복하며  
    dp[첫번째 노드 위치] = temp[k] 이렇게 담아 주고, k = 0 ~ N-1까지이다.  
    나머지 dp자리에는 0을 담아 준다
5. node = 첫번째 노드, n = node를 생성한다
6. while문을 사용하여  
    - dp[n/2] = dp[n] + dp[n+1] (두 노드의 합을 부모 노드에 저장한다)  
    - n += 2 (2개의 합씩 계산하므로 2씩 증가)
    - 만약 n == (node * 2) 이라면  
        node = node / 2  
        n = node  
        (node의 위치를 현재 노드들의 부모가 있는 높이로 이동하고 n에 그 부모노드의 첫번째 노드의 위치를 저장한다)
    - 만약 node == 1이라면 다한 것이므로 break
7. (1, N) for문을 사용하여 dp를 출력하는데  
    i == (2**t)-1이라면 end = ' '로 바꾸어 출력한다
------------------------------------
### 컴퓨터 학원
1. N의 값을 입력 받는다
2. n = 0, n = 1을 1, 3으로 초기화 한다
3. for (2, N+1) 까지 반복한다
    - dp[i] = dp[i-1] X 3 - (dp[i-1] - dp[i-2])
4. 출력할 때 796796의 나머지로 출력한다
------------------------------------
### 효율적인 화폐 구성


==> 나중에 다시 적기
---------------------------------------
### 먹보 수민이 (최소 방문 구하기)
1. 


-----------
### you
1. 문자열을 입력받아 모두 소문자화 하가
2. 문자에 You가 다른 단어에 붙어서라도 포함만 되어있으면 Me를 출력
3. 없으면 NO 출력
------------
### 중앙값
1. 리스트로 입력받기
2. sort()하기
3. 5개의 입력값이므로 dp[2] 값 출력
---------------------
###  숫자 맞추기


---------------------------
### 기둥 세우기
==> 가로 한층에 무조건 기둥 하나는 있어야 하고 세로 기준으로 보았을 때도 최소 기둥 하나가 존재해야 한다. ==> 이 조건을 만족 시킬 최소한의 세워야할 기둥 개수를 구하라
1. 가로줄 별로 입력받는다
    - 가로 한줄 받을 때 set으로 변환시킨다  
    ==> set은 중복을 없애고 저장한다
    - set에 0이 없으면 floor 배열에 가로 배열 순서를 입력한다.  
    ==> 즉 입력한 가로 층에 기둥이 하나도 없다는 것을 저장한다
2. 가로줄을 다 입력 받으면 floor 배열에 0이 없는 가로층이 전부 저장된다
3. 세로를 기준으로 기둥 개수를 본다.
    - 세로를 확인하면서 세로 첫째줄에 0이 없으면 floor에 저정한 숫자가 있으면 pop을 하고 count 에 1을 증가시킨다
    - 만약 floor에 저장한 것이 없으면 그냥 count 를 1한다
4. floor에 남은 것 len()으로 count에 더하기
--------------------------------
### N을 보는 시각
==> 00:00:00 - 23:25:29 사이에 숫자 N을 보는 초를 구한다
3시
시에 해당하는것
3시 
13시 
23시 
 분에 해당하는 것
 03
 13
 23
 43
 53
 30,31,32,....,39
 ==> 총 15분
초에 해당하는 것
 03
 13
 23
 43
 53
 30,31,32,....,39
 총 15초

식 ==> 
시간 = 3 * 60 * 60
분 = (24-3) * 15 * 60
초 = (24-3) * 45 * 15
총 : 43875

시간은 
1은 (01,10,11,12,13,14,15,16,17,18,19,21) ==> 12개
2는 (02,12,20,21,22,23) ==> 6개
3은 (03,13,23) ==> 3개
그외 나머지는 2개씩이다.

분은
1은 (01,10,11,12,13,14,15,16,17,18,19,21,31,41,51) ==> 15개
2는 (02,12,20,21,22,23,24,25,26,27,28,29,32,42,52) ==> 15개
5까지는 모두 15개
6은 (06,16,26,36,46,56) ==> 6개
9까지 모두 6개

초는 분과 같이 60이므로 같은 개수를 가진다
----------------------------------------
### 배수 만들기
==> 주어진 한자리 정수들을 가지고 만들 수 있는 가장 큰 300의 배수를 출력한다  
모든 자리 수의 합을 더하여 3의배수이면 그 수는 3의 배수이다
3의 배수와 *100 한 것이 300의 배수이다

1. 모든 수를 리스트에 더한 값을 구한다
2. 값 % 3 == 0 일때는 다음과 같다
    - 값을 sort()한다
    - 값을 다시 str로 변환한다음 join()을 사용해 하나의 str로 만든다
    - str인 수를 다시 int로 변환한다
    - 값 % 100 == 0 이면 값을 출력한다
    - 값 % 100 != 0 이면 -1을 출력한다.
3. 값 % 3 != 0 이면 -1을 출력한다
-------------------------------------
### 두더지 게임
 8 X 8 크기에 두더지가 올라오지 못하는 칸을 제외한 칸에서 두더지가 몇마리 올라오는지 구하기  
1. 0인 칸에서만 두더지가 올라올 수 있고, F에 두더지가 존재합니다
2. 짝수 번째 행은 0 1 0 1 0 1 0 1 이므로 0,2,4,6에서 올라 올 수 있다
3. 홀수 번째 행은 1 0 1 0 1 0 1 0 이므로 1,3,5,7에서 올라 올 수 있다
4. 8줄의 두더지 상태를 입력받는다
5. 입력받으면서 짝수번째에는 짝수번에 F 가 있으면 count+= 1한다
6. 입력받으면서 홀수번째에는 홀수번에 F 가 있으면 count+= 1한다
-------------------------------------
### 리버스게임
흰면, 검은면이 있는 바둑돌에서 한번에 한행 또는 한 열을 두집어 최소한의 흰색면이 보이도록 하기
행에 대해 모든 경우의 뒤집기를 한 후 
백준 1285 참고
------------------
### 바닥공사3
백준 타일채우기 참조
----------------------
